const PDFDocument = require('pdfkit');
const ExcelJS = require('exceljs');
const prisma = require('../../config/database');
const { ValidationError } = require('../../errors');

/**
 * Generate revenue report for a date range.
 */
async function generateRevenueData({ startDate, endDate, driverId }) {
  if (!startDate || !endDate) throw new ValidationError('Start and end dates required');

  const start = new Date(startDate);
  const end = new Date(endDate);
  
  if (isNaN(start.getTime()) || isNaN(end.getTime())) {
    throw new ValidationError('Invalid date format');
  }

  end.setHours(23, 59, 59, 999); // Set to end of the day

  const dayDiff = (end - start) / (1000 * 60 * 60 * 24);
  if (dayDiff > 90) throw new ValidationError('Date range cannot exceed 90 days');

  const where = {
    status: 'COMPLETED',
    actualEndTime: { gte: start, lte: end },
    ...(driverId && { driverId }),
  };

  const trips = await prisma.trip.findMany({
    where,
    include: {
      driver: { select: { id: true, name: true, email: true } },
      vehicle: { select: { id: true, plateNumber: true } },
    },
    orderBy: { actualEndTime: 'asc' },
  });

  if (trips.length === 0) {
    throw new ValidationError('REPORT_EMPTY_DATA', 'No completed trips found in this period');
  }


  // Get approved expenses in range
  const expenseWhere = {
    status: { equals: 'approved', mode: 'insensitive' },
    createdAt: { gte: start, lte: end },
    ...(driverId && { driverId }),
  };

  const expenses = await prisma.expense.findMany({
    where: expenseWhere,
    include: {
      category: { select: { name: true } },
      driver: { select: { id: true, name: true } },
    },
  });

  // Aggregate by driver
  const driverMap = {};
  for (const trip of trips) {
    const did = trip.driverId;
    if (!driverMap[did]) {
      driverMap[did] = {
        driverId: did,
        driverName: trip.driver.name,
        totalRevenue: 0,
        totalExpenses: 0,
        tripCount: 0,
        trips: [],
      };
    }
    driverMap[did].totalRevenue += parseFloat(trip.price);
    driverMap[did].tripCount += 1;
    driverMap[did].trips.push(trip);
  }

  for (const expense of expenses) {
    const did = expense.driverId;
    if (!driverMap[did]) {
      driverMap[did] = {
        driverId: did,
        driverName: expense.driver.name,
        totalRevenue: 0,
        totalExpenses: 0,
        tripCount: 0,
        trips: [],
      };
    }
    driverMap[did].totalExpenses += parseFloat(expense.amount);
  }

  const driverSummaries = Object.values(driverMap).map((d) => ({
    ...d,
    netRevenue: d.totalRevenue - d.totalExpenses,
  }));

  return {
    startDate: start.toISOString(),
    endDate: end.toISOString(),
    totalRevenue: driverSummaries.reduce((s, d) => s + d.totalRevenue, 0),
    totalExpenses: driverSummaries.reduce((s, d) => s + d.totalExpenses, 0),
    netRevenue: driverSummaries.reduce((s, d) => s + d.netRevenue, 0),
    driverSummaries,
    tripCount: trips.length,
    trips,
    expenses,
  };
}

/**
 * Generate PDF report.
 */
async function generatePDF(reportData, res) {
  const doc = new PDFDocument({ margin: 50 });
  res.setHeader('Content-Type', 'application/pdf');
  res.setHeader('Content-Disposition', 'attachment; filename=revenue_report.pdf');
  doc.pipe(res);

  // Header
  doc.fontSize(20).font('Helvetica-Bold').text('Fleet Management â€” Revenue Report', { align: 'center' });
  doc.moveDown();
  doc.fontSize(12).font('Helvetica').text(`Period: ${reportData.startDate.slice(0, 10)} to ${reportData.endDate.slice(0, 10)}`, { align: 'center' });
  doc.moveDown();

  // Summary table
  doc.fontSize(14).font('Helvetica-Bold').text('Summary', { underline: true });
  doc.moveDown(0.5);
  doc.fontSize(11).font('Helvetica');
  doc.text(`Total Revenue: ${reportData.totalRevenue.toFixed(2)} EGP`);
  doc.text(`Total Expenses: ${reportData.totalExpenses.toFixed(2)} EGP`);
  doc.text(`Net Revenue: ${reportData.netRevenue.toFixed(2)} EGP`);
  doc.text(`Total Trips: ${reportData.tripCount}`);
  doc.moveDown();

  // Driver breakdown
  doc.fontSize(14).font('Helvetica-Bold').text('Driver Breakdown', { underline: true });
  doc.moveDown(0.5);
  doc.fontSize(11).font('Helvetica');
  for (const driver of reportData.driverSummaries) {
    doc.text(`${driver.driverName}: Revenue ${driver.totalRevenue.toFixed(2)} EGP | Expenses ${driver.totalExpenses.toFixed(2)} EGP | Net ${driver.netRevenue.toFixed(2)} EGP | Trips: ${driver.tripCount}`);
  }

  doc.end();
}

/**
 * Generate Excel report.
 */
async function generateExcel(reportData, res) {
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'Fleet Management System';

  // Summary sheet
  const summarySheet = workbook.addWorksheet('Summary');
  summarySheet.columns = [
    { header: 'Metric', key: 'metric', width: 30 },
    { header: 'Value', key: 'value', width: 25 },
  ];
  summarySheet.addRow({ metric: 'Period Start', value: reportData.startDate.slice(0, 10) });
  summarySheet.addRow({ metric: 'Period End', value: reportData.endDate.slice(0, 10) });
  summarySheet.addRow({ metric: 'Total Revenue (EGP)', value: reportData.totalRevenue });
  summarySheet.addRow({ metric: 'Total Expenses (EGP)', value: reportData.totalExpenses });
  summarySheet.addRow({ metric: 'Net Revenue (EGP)', value: reportData.netRevenue });
  summarySheet.addRow({ metric: 'Total Trips', value: reportData.tripCount });

  // Drivers sheet
  const driverSheet = workbook.addWorksheet('Drivers');
  driverSheet.columns = [
    { header: 'Driver', key: 'name', width: 25 },
    { header: 'Revenue (EGP)', key: 'revenue', width: 20 },
    { header: 'Expenses (EGP)', key: 'expenses', width: 20 },
    { header: 'Net (EGP)', key: 'net', width: 20 },
    { header: 'Trips', key: 'trips', width: 15 },
  ];
  for (const d of reportData.driverSummaries) {
    driverSheet.addRow({
      name: d.driverName, revenue: d.totalRevenue,
      expenses: d.totalExpenses, net: d.netRevenue, trips: d.tripCount,
    });
  }

  // Trips sheet
  const tripsSheet = workbook.addWorksheet('Trips');
  tripsSheet.columns = [
    { header: 'Date', key: 'date', width: 25 },
    { header: 'Driver', key: 'driver', width: 25 },
    { header: 'Vehicle', key: 'vehicle', width: 20 },
    { header: 'Pickup', key: 'pickup', width: 35 },
    { header: 'Dropoff', key: 'dropoff', width: 35 },
    { header: 'Price', key: 'price', width: 15 },
    { header: 'Status', key: 'status', width: 15 },
  ];
  for (const t of reportData.trips) {
    tripsSheet.addRow({
      date: t.actualEndTime?.toISOString().slice(0, 19),
      driver: t.driver.name,
      vehicle: t.vehicle.plateNumber,
      pickup: t.pickupLocation,
      dropoff: t.dropoffLocation,
      price: parseFloat(t.price),
      status: t.status,
    });
  }

  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', 'attachment; filename=revenue_report.xlsx');
  await workbook.xlsx.write(res);
}

module.exports = { generateRevenueData, generatePDF, generateExcel };
